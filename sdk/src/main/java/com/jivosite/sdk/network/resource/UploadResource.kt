package com.jivosite.sdk.network.resourceimport androidx.annotation.MainThreadimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MediatorLiveDataimport com.jivosite.sdk.Jivoimport com.jivosite.sdk.model.pojo.file.AccessResponseimport com.jivosite.sdk.model.pojo.file.Fileimport com.jivosite.sdk.model.pojo.response.Responseimport com.jivosite.sdk.network.response.ApiResponseimport com.jivosite.sdk.network.retrofit.CountingRequestBodyimport com.jivosite.sdk.network.retrofit.error.JivoApiExceptionimport com.jivosite.sdk.support.async.Schedulersimport com.jivosite.sdk.support.ext.asRequestBodyimport okhttp3.MediaType.Companion.toMediaTypeimport okhttp3.MultipartBodyimport okhttp3.RequestBody/** * Created on 19.11.2020. * * @author Alexander Tavtorkin (tavtorkin@jivosite.com) */@Deprecated("not used for new media service")abstract class UploadResource(schedulers: Schedulers) {    private val result = MediatorLiveData<Resource<String>>()    init {        schedulers.ui.execute {            setValue(Resource.loading())            val accessSource: LiveData<ApiResponse<AccessResponse>> = getAccess()            result.addSource(accessSource) { accessResponse ->                result.removeSource(accessSource)                handleApiResponse(accessResponse)?.let { apiResponse ->                    schedulers.io.execute {                        val file = file()                        if (file.inputStream != null) {                            val fileName = file.name                            val mimeTypeMap = file.mimeType                            val body = MultipartBody.Part.createFormData(                                "file",                                fileName,                                CountingRequestBody(file.inputStream.asRequestBody(mimeTypeMap.toMediaType())) { value ->                                    result.postValue(Resource.progressUpdate(value))                                })                            val (url, key, map) = (apiResponse.body as AccessResponse).run {                                Triple(url, key, requestBody(file.name, file.mimeType))                            }                            schedulers.ui.execute {                                val uploadSource = upload(url, map, body)                                result.addSource(uploadSource) { uploadResponse ->                                    result.removeSource(uploadSource)                                    handleApiResponse(uploadResponse)?.let {                                        val location = it.headers?.get("Location")?.get(0)                                        if (location != null) {                                            setValue(Resource.success("$url/$key"))                                        } else {                                            setValue(                                                Resource.error(                                                    "There is no location header in upload response",                                                    JivoApiException(mapOf("empty_headers" to ""))                                                )                                            )                                        }                                    }                                }                            }                        } else {                            result.postValue(                                Resource.error(                                    "Can not read file",                                    JivoApiException(mapOf("can_not_read" to ""))                                )                            )                        }                    }                }            }        }    }    private fun <T> handleApiResponse(apiResponse: ApiResponse<T>?): ApiResponse<T>? {        return if (apiResponse != null) {            if (apiResponse.isSuccessful) {                val body: T? = apiResponse.body                if (body == null) {                    return apiResponse                } else if (body is Response) {                    if (body.isOk) {                        return apiResponse                    } else {                        val errors = HashMap<String, String>()                        body.errorList?.forEach {                            errors[it] = ""                        }                        val error = JivoApiException(errors)                        setValue(Resource.error(error.localizedMessage, error))                        null                    }                } else {                    setValue(                        Resource.error(                            "Response body not instantiate Response class",                            JivoApiException(mapOf("wrong_body_class" to ""))                        )                    )                    null                }            } else {                val error = apiResponse.throwable                setValue(Resource.error(error?.localizedMessage, error))                null            }        } else {            Jivo.e("There is something wrong in UploadResource")            setValue(Resource.error(null, null))            null        }    }    @MainThread    private fun setValue(newValue: Resource<String>) {        if (result.value != newValue) {            result.value = newValue        }    }    fun asLiveData() = result as LiveData<Resource<String>>    protected abstract fun getAccess(): LiveData<ApiResponse<AccessResponse>>    protected abstract fun file(): File    protected abstract fun upload(        url: String,        map: HashMap<String, RequestBody>,        body: MultipartBody.Part,    ): LiveData<ApiResponse<Void>>    class Builder(private val schedulers: Schedulers) {        private var getAccess: (() -> LiveData<ApiResponse<AccessResponse>>)? = null        private var file: (() -> File)? = null        private var upload: ((String, HashMap<String, RequestBody>, MultipartBody.Part) -> LiveData<ApiResponse<Void>>)? =            null        fun getAccess(call: () -> LiveData<ApiResponse<AccessResponse>>): Builder {            this.getAccess = call            return this        }        fun file(call: () -> File): Builder {            this.file = call            return this        }        fun upload(call: (String, HashMap<String, RequestBody>, MultipartBody.Part) -> LiveData<ApiResponse<Void>>): Builder {            this.upload = call            return this        }        fun build(): UploadResource {            return object : UploadResource(schedulers) {                override fun getAccess(): LiveData<ApiResponse<AccessResponse>> = requireNotNull(getAccess) {                    "You need to declare getAccess method"                }.invoke()                override fun file(): File = requireNotNull(file) {                    "You need to declare file method"                }.invoke()                override fun upload(                    url: String,                    map: HashMap<String, RequestBody>,                    body: MultipartBody.Part,                ): LiveData<ApiResponse<Void>> {                    return requireNotNull(upload) { "You need to declare upload method" }.invoke(url, map, body)                }            }        }    }}