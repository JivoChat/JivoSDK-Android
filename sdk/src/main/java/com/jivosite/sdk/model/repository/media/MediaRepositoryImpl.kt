package com.jivosite.sdk.model.repository.mediaimport android.webkit.URLUtilimport androidx.lifecycle.LiveDataimport com.jivosite.sdk.api.MediaApiimport com.jivosite.sdk.model.cache.MemoryCacheimport com.jivosite.sdk.network.resource.HeadResourceimport com.jivosite.sdk.network.resource.Resourceimport com.jivosite.sdk.support.async.Schedulersimport com.jivosite.sdk.support.ext.loadSilentlyResourceimport com.jivosite.sdk.support.ext.parseContentDispositionimport java.util.regex.Patternimport javax.inject.Inject/** * Created on 12.10.2021. * * @author Alexander Tavtorkin (av.tavtorkin@gmail.com) */class MediaRepositoryImpl @Inject constructor(    val api: MediaApi,    val schedulers: Schedulers) : MediaRepository {    companion object {        val MEDIA_PATH_PATTERN: Pattern = Pattern.compile("https://media.*\\.jivosite\\.com.*")    }    private val mediaItemsCache = MemoryCache<String, MediaItemState>()    override fun getMediaItemState(path: String) = when {        MEDIA_PATH_PATTERN.matcher(path).matches() -> {            mediaItemsCache[path, MediaItemState.Initial].also { state ->                if (state.value is MediaItemState.Initial) {                    createRequest(path).loadSilentlyResource {                        progress { if (it) mediaItemsCache[path] = MediaItemState.Loading }                        result {                            if (it.isExpired) {                                mediaItemsCache[path] = MediaItemState.Expired                            } else {                                mediaItemsCache[path] = MediaItemState.Success(media = it)                            }                        }                        error { mediaItemsCache[path] = MediaItemState.Error() }                    }                }            }        }        else -> mediaItemsCache[path, MediaItemState.Success(Media(path = path, name = URLUtil.guessFileName(path, null, null)))]    }    private fun createRequest(path: String): LiveData<Resource<Media>> {        return HeadResource.Builder<Media>(schedulers)            .apiCall { api.getMedia(path) }            .handleResponse { headers ->                val fileName = getFileName(headers)                if (fileName.isNotEmpty()) {                    Media(name = fileName, path = path, isExpired = headers.isEmpty(), hasMediaService = true)                } else {                    Media(path = path, isExpired = headers.isEmpty())                }            }            .build()            .asLiveData()    }    private fun getFileName(headers: Map<String, List<String>>? = null): String {        val contentDisposition = headers?.get("content-disposition")?.get(0)        return contentDisposition.parseContentDisposition()    }}sealed class MediaItemState {    object Initial : MediaItemState()    object Loading : MediaItemState()    data class Success(        val media: Media = Media()    ) : MediaItemState()    object Expired : MediaItemState()    data class Error(        val messageError: String? = null    ) : MediaItemState()}data class Media(    val name: String = "",    val path: String = "",    val isExpired: Boolean = false,    val hasMediaService: Boolean = false) {    fun thumb(width: Int): String = if (hasMediaService) "$path?width=$width&thumb" else path}