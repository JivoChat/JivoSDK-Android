package com.jivosite.sdk.model.repository.mediaimport android.webkit.URLUtilimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport com.jivosite.sdk.api.MediaApiimport com.jivosite.sdk.model.cache.MemoryCacheimport com.jivosite.sdk.network.resource.HeadResourceimport com.jivosite.sdk.network.resource.Resourceimport com.jivosite.sdk.support.async.Schedulersimport java.util.*import java.util.regex.Patternimport javax.inject.Inject/** * Created on 12.10.2021. * * @author Alexander Tavtorkin (av.tavtorkin@gmail.com) */class MediaRepositoryImpl @Inject constructor(    val api: MediaApi,    val schedulers: Schedulers) : MediaRepository {    companion object {        val MEDIA_PATH_PATTERN: Pattern = Pattern.compile("https://media.*\\.jivosite\\.com.*")    }    private val cache = MemoryCache<String, Resource<Media>>()    override fun getMedia(path: String): LiveData<Resource<Media>> {        return when {            MEDIA_PATH_PATTERN.matcher(path).matches() -> {                return if (cache.contains(path)) {                    val resource = cache[path]                    if (resource.value?.data?.isExpired == false) {                        createRequest(path).also {                            cache.setKey(path, it as MutableLiveData<Resource<Media>>)                        }                    } else {                        resource                    }                } else {                    createRequest(path).also {                        cache.setKey(path, it as MutableLiveData<Resource<Media>>)                    }                }            }            else -> {                cache[path, Resource.success(Media(path = path, name = getFileName(path)))]            }        }    }    private fun createRequest(path: String): LiveData<Resource<Media>> {        return HeadResource.Builder<Media>(schedulers)            .apiCall { api.getMedia(path) }            .handleResponse { headers ->                val fileName = getFileName(path, headers)                if (getFileName(path, headers).isNotEmpty()) {                    Media(name = fileName, path = path, isExpired = headers.isEmpty())                } else {                    Media(path = path, isExpired = headers.isEmpty())                }            }            .build()            .asLiveData()    }    private fun getFileName(path: String, headers: Map<String, List<String>>? = null): String {        val contentDisposition = headers?.get("content-disposition")?.get(0)        val contentType = headers?.get("Content-Type")?.get(0)        return URLUtil.guessFileName(path, contentDisposition, contentType) ?: UUID.randomUUID().toString()    }}data class Media(    val name: String = "",    val path: String = "",    val isExpired: Boolean = false)